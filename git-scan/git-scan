#!/bin/python

import subprocess
from termcolor import colored
import toml
import argparse
import enum
import pathlib
import glob

"""
Configuration can be used to control which ones are checked (default: all)
Checks should be applied to every branch
tmux option to open projects in window -- auto-show diff, etc.
option to pull all and report on errors

testing: create temp repo
learn: to execute everything over ssh

detect all git repos within a repo as part of config (but not submodules?)
add (optional) groups for groups of repos

see related project: https://github.com/totten/git-scan
see creating git command: https://github.com/rotati/wiki/wiki/Create-custom-Git-command
                          https://dev.to/shobhit/git-refresh-4hn
"""

class History(enum.Enum):
    EQUAL    = enum.auto()  # history is the same as remote
    PULL     = enum.auto()  # history is behind remote
    PUSH     = enum.auto()  # history is ahead of remote
    DIVERGED = enum.auto()  # history has diverged from remote

def run_git_command(options, git_path):
    """Run a git command
    
    Arguments:
        options    list of commands following git
        git_path   path to git repository
    """
    cmd = subprocess.Popen(['git',] + list(options), stdout=subprocess.PIPE, cwd=git_path)
    text = cmd.communicate()[0].decode()
    return text

def git_diff(git_path):
    """run git diff"""
    return run_git_command(['diff'], git_path)

def git_fetch(git_path):
    """run git fetch"""
    return run_git_command(['fetch'], git_path)

def local_sha(git_path):
    """get the local SHA"""
    return run_git_command(['rev-parse', '@'], git_path).strip()

def remote_sha(git_path):
    """get the remote SHA"""
    return run_git_command(['rev-parse', '@{u}'], git_path).strip()

def base_sha(git_path):
    """get the remote base SHA"""
    return run_git_command(['merge-base', '@', '@{u}'], git_path).strip()

def git_untracked_files(git_path):
    """get untracked files"""
    return run_git_command(['ls-files', '--others', '--exclude-standard'], git_path)

def git_stash_list(git_path):
    """get list of stashes"""
    return run_git_command(['stash', 'list'], git_path)

def get_history(git_path, fetch=False):
    """Obtain the status of the history relative to the remote

    Arguments:
        git_path   path to git repository
        fetch      (bool) If True, fetch remote data before getting history
    """
    if fetch:
        git_fetch(git_path)

    local = local_sha(git_path)
    remote = remote_sha(git_path)
    base = base_sha(git_path)

    if local == remote:
        return History.EQUAL
    elif local == base:
        return History.PULL
    elif remote == base:
        return History.PUSH
    else:
        return History.DIVERGED

def get_remote_branches(git_path):
    """get a list of the remote branch names"""
    out = run_git_command(['ls-remote', '--heads', '-q'], git_path).strip()
    out = out.split()[1::2]   # skip the SHAs

    remote_branches = []
    for path in out:
        remote_branches.append(pathlib.Path(path).name)
    return remote_branches

def get_local_branches(git_path):
    """get a list of the local branch names"""
    out = run_git_command(['for-each-ref', '--format=%(refname)', 'refs/heads/'], git_path).split()

    local_branches = []
    for path in out:
        local_branches.append(pathlib.Path(path).name)
    return local_branches

def get_dangling_branches(git_path):
    """get branches that do not exist on the remote"""
    remote_branches = get_remote_branches(git_path)
    local_branches = get_local_branches(git_path)

    dangling = filter(lambda b: b not in remote_branches, local_branches)
    return dangling

def run_parser():
    parser = argparse.ArgumentParser()

    parser.add_argument('--pull', action='store_true', default=False,
            help="run 'git pull' on all repositories that do not have a conflict")

    parser.add_argument('--push', action='store_true', default=False,
            help="run 'git push' on all repositories that do not have a conflict")

    parser.add_argument('--tmux', action='store_true', default=False,
            help="open all repositories that require changes in tmux windows")

    parser.add_argument('--ssh', type=str, nargs='?',
            help="run git-scan on a different machine over ssh")

    parser.add_argument('--repo', type=str, nargs='*',
            help="run git-scan over the given repositories")

    parser.add_argument('--no-fetch', action='store_true', default=False,
            help="do not run any 'git fetch' commands")

    subparsers = parser.add_subparsers(dest="action")

    add_parser = subparsers.add_parser('add',
            help="add a new repository to the list of scanned repositories")
    add_parser.add_argument('repository', type=str, nargs='*',
            help='list of repositories to be removed')

    remove_parser = subparsers.add_parser('remove',
            help="remove a repository from the list of scanned repositories")
    remove_parser.add_argument('repository', type=str, nargs='*',
            help='list of repositories to be removed')

    list_parser = subparsers.add_parser('list',
            help="list all scannable repositories")
    list_parser.add_argument('--resolve', action='store_true', default=False,
            help="resolve the absolute paths")

    return parser.parse_args()

def get_config_path():
    path = pathlib.Path('~/.config/git-scan/git-scan.conf').expanduser()
    return path

def get_config():
    path = get_config_path()
    config = toml.load(path)
    return config

def add_config(repositories):
    """add new repositories to the configuration file"""
    config_path = get_config_path()
    config = toml.load(config_path)

    for repo in repositories:
        path = pathlib.Path(repo).resolve().as_posix()
        config['repositories'].append(path)

    toml.dump(config, open(config_path, 'w'))

def remove_config(repositories):
    """remove repositories from the configuration file"""
    config_path = get_config_path()
    config = toml.load(config_path)

    for repo in repositories:
        path = pathlib.Path(repo).resolve()
        for i, other_path in enumerate(config['repositories']):
            try:
                if path.samefile(pathlib.Path(other_path).expanduser()):
                    config['repositories'].pop(i)
                    break

            except FileNotFoundError:  # in case of globs
                if path.match(other_path):
                    config['repositories'].pop(i)
                    break

    toml.dump(config, open(config_path, 'w'))

def get_paths():
    config = get_config()
    repos = config['repositories']

    paths = []
    for repo in repos:
        path = pathlib.Path(repo)
        path = path.expanduser()
        globbed = glob.glob(str(path))
        if len(globbed) > 1:
            paths.extend(globbed)
        else:
            paths.append(str(path))

    paths = list(set(paths))
    return paths

def list_config(resolve=False):
    config = get_config()
    repos = config['repositories']
    for repo in repos:
        if not resolve:
            print(repo)
        else:
            path = pathlib.Path(repo).expanduser()
            globbed = glob.glob(str(path))
            if len(globbed) > 1:
                print('\n'.join(globbed))
            else:
                print(path)

if __name__ == '__main__':
    args = run_parser()

    if args.action == 'add':
        add_config(args.repository)
        exit()
    elif args.action == 'remove':
        remove_config(args.repository)
        exit()
    elif args.action == 'list':
        list_config(resolve=args.resolve)
        exit()

    paths = get_paths()
    for path in paths:
        #TODO: don't git-fetch if a repo doesn't have a remote-url
        git_fetch(path)

        diff = git_diff(path)
        history = get_history(path)
        untracked = git_untracked_files(path)
        stashes = git_stash_list(path)
        dangling_branches = get_dangling_branches(path)

        ### display
        print(colored(pathlib.Path(path).name, color='yellow', attrs=['bold']), end='')
        print(colored(' - ' + path, color='yellow'))
        tab = ' '*6
        if diff:
            print(tab + 'diffs')
        if history != history.EQUAL:
            print(tab + str(history))
        if untracked:
            print(tab + 'untracked files')
        if stashes:
            print(tab + 'stashed changes')
        if dangling_branches:
            f = ', '.join([colored(b, attrs=['underline']) for b in dangling_branches])
            print(tab + 'branches dangling: ' + f)

        if path != paths[-1]:
            print()
